- Feature Name: symbol_name_mangling_v2
- Start Date: 2018-11-27
- RFC PR: (leave this empty)
- Rust Issue: (leave this empty)

# Summary
[summary]: #summary

This RFC proposes a new mangling scheme that describes what the symbol names generated by the Rust compiler. This new scheme has a number of advantages over the existing one which has grown over time without a clear direction. The new scheme is consistent, does not depend on compiler internals, and the information it stores in symbol names can be decoded again which provides an improved experience for users of external tools that work with Rust symbol names. The new scheme is based on the name mangling scheme from the [Itanium C++ ABI][itanium-mangling].

Note that, at this point, the new mangling scheme would not be part of the language specification or the specification of a stable Rust ABI. In the future it could be part of both and it is designed to be stable and extensible but for the time being it would still be an implementation detail of the Rust compiler.

# Motivation
[motivation]: #motivation

Due to its ad-hoc nature, the compiler's current name mangling scheme has a
number of drawbacks:

- It depends on compiler internals and its results cannot be replicated by another compiler implementation or external tool.
- Information about generic parameters and other things is lost in the mangling process. One cannot extract the type arguments of a monomorphized function from its symbol name.
- The current scheme is inconsistent: most paths use Itanium style encoding, but some don't.
- The symbol names it generates can contain `.` characters which is not generally supported on all platforms. \[[1][gas]\]\[[2][lld-windows-bug]\] \[[3][thin-lto-bug]\]

[gas]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Symbol-Names
[lld-windows-bug]: https://github.com/rust-lang/rust/issues/54190
[thin-lto-bug]: https://github.com/rust-lang/rust/issues/53912

The proposed scheme solves these problems:

- It is defined in terms of the language, not in terms of compiler data-structures that can change at any given point in time.
- It encodes information about generic parameters in a reversible way.
- It has a consistent definition that does not rely on pretty-printing certain language constructs.
- It generates symbols that only consist of the characters `A-Z`, `a-z`, `0-9`, and `_`.

This should make it easier for third party tools to work with Rust binaries.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

The following section will lay out the requirements for a name mangling scheme and then introduce the actual scheme through a series of ever more complex examples.

## Requirements for a Symbol Mangling Scheme

A symbol mangling scheme has a few goals, one of them essential, the rest of them desirable. The essential one is:

- The scheme must provide an unambiguous string encoding for everything that can end up in a binary's symbol table.

"Unambiguous" means that no two distinct compiler-generated entities (that is, mostly object code for functions) must be mapped to the same symbol name. This disambiguation is the main purpose of the hash-suffix in the current, legacy mangling scheme. The scheme proposed here, on the other hand, achieves it in a way that allows to also satisfy a number of additional desirable properties of a mangling scheme:

 - A mangled symbol should be *decodable* to some degree. That is, it is desirable to be able to tell which exact concrete instance of e.g. a polymorphic function a given symbol identifies. This is true for external tools, backtraces, or just people only having the binary representation of some piece of code available to them. With the current scheme, this kind of information gets lost in the magical hash-suffix.

 - It should be possible to predict the symbol name for a given source-level construct. For example, given the definition `fn foo<T>() { ... }`, the scheme should allow to construct, by hand, the symbol names for e.g. `foo<u32>` or `foo<extern fn(i32, &mut SomeStruct<(char, &str)>, ...) -> !>()`. Since the current scheme generates its hash from the values of various compiler internal data structures, not even an alternative compiler implementation could predict the symbol name, even for simple cases.

 - A mangling scheme should be platform-independent. This is mainly achieved by restricting the character set to `A-Z`, `a-z`, `0-9`, `_`. All other characters might have special meaning in some context (e.g. `.` for MSVC `DEF` files) or are simply not supported (e.g. Unicode).

 - The scheme should be efficient, meaning that the symbols it produces are not unnecessarily long (because that takes up space in object files and means more work for the compiler and the linker). In addition, generating or demangling a symbol name should not be too computationally expensive.

The RFC also has a couple of non-goals:

 - Source-level definitions can contain components that will not show up in symbol names, like lifetimes (as in `fn foo<'a>()`). This RFC does not define a mangling for cases like these. One might want to cover them "for completeness" but they are not actually needed.

 - The mangling scheme does not try to be compatible with an existing C++ mangling scheme. While it might sound tempting to encode Rust symbols with an existing scheme, it is the author's opinion that the actual benefits are small (C++ tools would not demangle to Rust syntax, demanglings would be hard to read) and at the same time supporting a Rust-specific scheme in existing tools seems quite feasible (many tools like GDB, LLDB, binutils, and valgrind already have specialized code paths for Rust symbols).



## The Mangling Scheme by Example

This section will develop an overview of the mangling scheme by walking through a number of examples. We'll start with the simplest case -- and will see how that already involves things that might be surprising.

### Free-standing Functions and Statics

A free-standing function is fully identified via its absolute path. For example, the following function

```rust
mod foo {
  fn bar() {}
}
```

has the path `foo::bar` and `N3foo3barE` is a mangling of that path that complies to the character set we are restricted to. Why this format with numbers embedded in it? It is the encoding that the [Itanium C++ ABI][itanium-mangling] name mangling scheme uses for "nested names" (i.e. paths). The scheme proposed here will also use this format because it does not need termination tokens for identifiers (which are hard to come by with our limited character set).

However, the symbol name above does not unambiguously identify the function in every context. It is perfectly valid for another crate to also define `mod foo { fn bar() {} }` somewhere. So in order to avoid conflicts in such cases, the absolute path must always include the crate name and disambiguator, as in `N15mycrate_4a3b56d3foo3barE` (the crate disambiguator is used to disambiguate different versions of the same crate. It is an existing concept and not introduced by this RFC).

There is another possible ambiguity that we have to take care of. Rust has two distinct namespaces: the type and the value namespace. This leads to a path of the form `crate_id::foo::bar` not uniquely identifying the item `bar` because the following snippet is legal Rust code:

```rust
fn foo() {
    fn bar() {}
}

mod foo {
    fn bar() {}
}
```

The function `foo` lives in the value namespaces while the module `foo` lives in the type namespace. They don't interfere. In order to make the symbol names for the two distinct `bar` functions unique, we thus add a suffix to name components in the value namespace, so case one would get the symbol name `N15mycrate_4a3b56d3fooV3barVE` and case two get the name `N15mycrate_4a3b56d3foo3barVE` (notice the difference: `3fooV` vs `3foo`).

There is on final case of name ambiguity that we have to take care of. Because of macro hygiene, multiple items with the same name can appear in the same context. The compiler internally disambiguates such names by augmenting them with a numeric index. For example, the first occurrence of the name `foo` within its parent is actually treated as `foo'0`, the second occurrence would be `foo'1`, the next `foo'2`, and so one. The mangling scheme will adopt this setup by appending a disambiguation suffix to each identifier with a non-zero index. So if macro expansion would result in the following code:

```rust
mod foo {
    fn bar'0() {}
    // The second `bar` function was introduced by macro expansion.
    fn bar'1() {}
}
```
Then we would encode the two functions symbols as `N15mycrate_4a3b56d3foo3barVE` and `N15mycrate_4a3b56d3foo3barVs_E` respectively (note the `s_` suffix in the second case). Details on the shape of this suffix are provided in the reference-level description.

As opposed to C++ and other languages that support function overloading, we don't need to include function parameter types in the symbol name. Rust does not allow two functions of the same name but different arguments.

The final symbol name for the function would also include the prefix `_R` that is common to all symbol names generated by this scheme:

```
  _RN15mycrate_4a3b56d3foo3barVE

  <><-------------------------->
   |             |
prefix    absolute path


```

### Generic Functions

Each monomorphization of a generic function has its own symbol name. The monomorphizations are disambiguated by the list of concrete generic arguments. These arguments are listed as a suffix, starting with `I`, after the name they belong to. So the instance

```rust
std::mem::align_of::<f64>
```

would be mangled to

```
_RN12std_a1b2c3d43mem8align_ofVIdEE
                               ^^^
                               |||
     start of argument list ---+|+--- end of argument list
                                |
                               f64
```

where `I` starts the list of arguments, `d` designates `f64` and `E` ends the argument list. As we can see, we need to be able to represent all kinds of types that can be part of such an argument list. (In the future, when const generics get added to the language, we might also need to represent *values*) These kinds of types are:

 - basic types (`char`, `()`, `str`, `!`, `i8`, `i16`, ...)
 - reference and pointers types, shared and `mut`
 - tuples
 - arrays, with and without fixed size (e.g. `[u8]`, `[u8; 17]`, or as part of a slice type `&[char]`)
 - structs, enums, closures, and other named types, possibly with their own set of type arguments
 - function types such as `fn(&i32) -> u16`

Basic types are all encoded via a single lower-case letter, like in the Itanium scheme. Named types are encoded as their absolute path (including arguments) like is done for function symbols. Composites like references, tuples, and function types all follow a simple grammar given in the reference-level explanation below. Here are some example manglings to get a general feel of what they look like:

 - `std::mem::align_of::<usize>`: `_RN12std_a1b2c3d43mem8align_ofVIjEE`
 - `std::mem::align_of::<&char>`: `_RN12std_a1b2c3d43mem8align_ofVIRcEE`
 - `std::mem::align_of::<std::mem::Discriminant>`: `_RN12std_a1b2c3d43mem8align_ofVIN12std_a1b2c3d43mem12DiscriminantEEE`
 - `std::mem::align_of::<&mut (&str,())>`: `_RN12std_a1b2c3d43mem8align_ofVIWTRrvEEE`

There's one more thing we have to take into account for generic functions: The compiler may produce "crate-local" copies of a monomorphization. That is, if there is a function `foo<T>` which gets used as `foo<u32>` in two different crates, the compiler (depending on the optimization level) might generate two distinct functions at the LLVM IR level, each with it's own symbol. In order to support this without running into conflicts, symbol names for monomorphizations must include the id of the crate they are instantiated for. This scheme does this by appending an `<crate-id>` suffix to the symbol. So for example the mangling for `std::mem::align_of::<usize>` would actually look like this:

```
_RN12std_a1b2c3d43mem8align_ofVIjEE12foo_a1b2c3d4 (for crate "foo[a1b2c3d4])
_RN12std_a1b2c3d43mem8align_ofVIjEE12bar_11223344 (for crate "bar[11223344])
```


### Closures and Closure Environments

The scheme needs to be able to generate symbol names for the function containing the code of a closure and it needs to be able to refer to the type of a closure if it occurs as a type argument. As closures don't have a name, we need to generate one. The scheme proposes to use the namespace and disambiguation mechanisms already introduced above for this purpose. Closures get their own "namespace" (i.e. they are neither in the type nor the value namespace), and each closure has an empty name with a disambiguation index (like for macro hygiene) identifying them within their parent. The full name of a closure is then constructed like for any other named item:

```rust
mod foo {
  fn bar(x: u32) {
    let a = |x| { x + 1 }; // local name: 0C
    let b = |x| { x + 2 }; // local name: 0Cs_

    a(b(x))
  }
}

```

In the above example we have two closures, the one assigned to `a` and the one assigned to `b`. The first one would get the local name `0C` and the second one the name `0Cs_`. The `0` signifies the length of their (empty) name. The `C` is the namespace tag, analogous to the `V` tag for the value namespace. The `s_` for the second closure is the disambiguation index (index `0` is, again, encoded by not appending a suffix). Their full names would then be `N15mycrate_4a3b56d3foo3barV0CE` and `N15mycrate_4a3b56d3foo3barV0Cs_E` respectively.


### Methods

Methods are nested within `impl` or `trait` items. As such it would be possible to construct their symbol names as paths like `my_crate::foo::{{impl}}::some_method` where `{{impl}}` somehow identifies the the `impl` in question. Since `impl`s don't have names, we'd have to use an indexing scheme like the one used for closures (and indeed, this is what the compiler does internally). Adding in generic arguments to, this would lead to symbol names looking like `my_crate::foo::impl'17::<u32, char>::some_method`.

However, in the opinion of the author these symbols are very hard to map back to the method they represent. Consider a module containing dozens of types, each with multiple `impl` blocks generated via `#[derive(...)]`. In order to find out which method a symbol maps to, one would have to count the number of handwritten and macro generated `impl` blocks in the module, and hope that one correctly guessed the number of `impl` blocks introduced by the given derive-macro (each macro invocation can introduce `0..n` such blocks). The name of the method might give a hint, but there are still likely to be dozens of methods named `clone`, `hash`, `eq`, et cetera.

The RFC therefore proposes to keep symbol names close to how methods are represented in error messages, that is:

- `Foo<u32, char>::some_method` for inherent methods, and
- `<Foo<u32, char> as SomeTrait<Quux>>::some_method` for trait methods.

This can be achieved by extending the definition of absolute paths that we have used so far. Instead of the path root always being a crate-id, we now also allow a path to start with a single type (i.e. the self-type of an inherent method) or with a pair of self-type and the trait being implemented. The kind of root is indicated by the first character of the `N` starting the path:

- a decimal digit signifies a path with a crate-id root (since crate-ids always start with a digit),
- an `M` signifies a path with a single type as its root, and
- an `X` signifies a path with a self-type/trait pair as its root.

Thus, this extended form of paths would have the following syntax:

```
<abs-path>  := N <path-root> <ident>* [I <generic-arguments> E] E

<path-root> := <crate-id>
            |  M <type>
            |  X <type> <abs-path>
```

Here are some examples for complete symbol names:

```
<u32 as mycrate::Foo>::foo => _RNXmN12mycrate_abcd3FooE3fooVE
mycrate::Foo<u32>::foo => _RNMN12mycrate_abcd3FooImEE3fooVE
<mycrate::Foo<u32> as mycrate::Bar<u64>>::foo => _RNXN12mycrate_abcd3FooImEEN12mycrate_abcd3BarIyEE3fooVE
```


### Items Within Specialized Trait Impls

In Rust one can define items within generic items, e.g. functions or impls, like in the following example:

```rust
fn foo<T>(a: T) -> (u32, T) {
  static mut X: u32 = 0;

  unsafe {
    X += 1;
    (X, a)
  }
}
```

The `X` here (or any other such nested definition) does not inherit the generic context. `X` is non-generic, and a function defined in its place would be too. Consequently, when giving the path to something defined within a generic item, one does not specify the generic arguments because they add no information. The fully qualified name of `X` is thus `my_crate[a1b2c3d4]::foo::X` and its symbol name:

```
_RN15mycrate_4a3b56d3fooF1XFE
```

However, there is at least one case where the type arguments *do* matter for a definition like this, and that is when trait specialization is used. Consider the following piece of code:

```rust
trait Foo<T> {
  fn foo() -> T;
}

struct Bar<T>(T);

impl<T> Foo<T> for Bar<T> {
  default fn foo() -> T {
    static MSG: &str = "sry, no can do";
    panic!("{}", MSG)
  }
}

impl<T: Default> Foo<T> for Bar<T> {
  fn foo() -> T {
    static MSG: &str = "it's a go!";
    println!("{}", MSG);
    T::default()
  }
}

```

Notice that, if one just omits the type arguments, both `MSG` statics have the path `<Bar as Foo>::foo::MSG`. However, we cannot disambiguate by adding type arguments, because we don't have any concrete types to substitute the arguments for. Therefore, we have to disambiguate the `impls`. Since trait specialization is an unstable feature of Rust and the details are in flux, this RFC does not try to provide a mangling based on the `where` clauses of the specialized `impls`. Instead it proposes to re-use the "numeric disambiguator" form already used for macro hygiene and closures. Thus, conflicting `impls` would be disambiguated via an implementation defined suffix, as in `<Bar as Foo>'1::foo::MSG` and `<Bar as Foo>'2::foo::MSG`. This encoding introduces minimal additional syntax and can be replaced with something more human-readable once the definition of trait specialization is final.


### Unicode Identifiers

Rust allows Unicode identifiers but our character set is restricted to ASCII alphanumerics, and `_`. In order to transcode the former to the latter, we use the same approach as Swift, which is: encode all non-ascii identifiers via [Punycode][punycode], a standardized and efficient encoding that keeps encoded strings in a rather human-readable format. So for example, the string

```
"G√∂del, Escher, Bach"
```

is encoded as

```
"Gdel, Escher, Bach-d3b"
```

which, as opposed to something like _Base64_, still gives a pretty good idea of what the original string looked like.

Each component of a name, i.e. anything that starts with the number of bytes to read in the examples above, is encoded individually. Components encoded this way are augmented with a `u` suffix so that demanglers know that the identifier needs further decoding. As an example, the function:

```rust
mod g√∂del {
  mod escher {
    fn bach() {}
  }
}
```

would be mangled as:

```
_RN15mycrate_4a3b56d8gdel_Fqau6escher4bachVE`
                    <-------->
                Unicode component
```

### Compression/Substitution

The length of symbol names has an influence on how much work compiler, linker, and loader have to perform. The shorter the names, the better. At the same time, Rust's generics can lead to rather long names (which are often not visible in the code because of type inference and `impl Trait`). For example, the return type of the following function:

```rust
fn quux(s: Vec<u32>) -> impl Iterator<Item=(u32, usize)> {
    s.into_iter()
     .map(|x| x+1)
     .filter(|&x| x > 10)
     .zip(0..)
     .chain(iter::once((0, 0)))
}
```

is

```rust
std::iter::Chain<
  std::iter::Zip<
    std::iter::Filter<
      std::iter::Map<
        std::vec::IntoIter<u32>,
        [closure@src/main.rs:16:11: 16:18]>,
      [closure@src/main.rs:17:14: 17:25]>,
    std::ops::RangeFrom<usize>>,
  std::iter::Once<(u32, usize)>>
```

It would make for a long symbol name if this types is used (maybe repeatedly) as a generic argument somewhere. C++ has the same problem with its templates; which is why the Itanium mangling introduces the concept of compression. If a component of a definition occurs more than once, it will not be repeated and instead be emitted as a substitution marker that allows to reconstruct which component it refers to. The scheme proposed here will use the same approach.

The exact scheme will be described in detail in the reference level explanation below but it roughly works as follows: As a mangled symbol name is being built or parsed, we build up a dictionary of "substitutions", that is we keep track of things a subsequent occurrence of which could be replaced by a substitution marker. The substitution marker is then the lookup key into this dictionary. The things that are eligible for substitution are (1) all prefixes of absolute paths (including the entire path itself) and (2) all types except for basic types. If a substitutable item is already present in the dictionary it does not generate a new key. Here's an example in order to illustrate the concept:

```

    std::iter::Chain<std::iter::Zip<std::vec::IntoIter<u32>, std::vec::IntoIter<u32>>>
$0: ---
$1: ---------
$2: ----------------
$3:                  --------------
$4:                                 --------
$5:                                 ------------------
$6:                                 -----------------------
$7:                  ----------------------------------------------------------------
$8: ----------------------------------------------------------------------------------
```

The indices on the left are the dictionary keys. The prefixes `std`, `std::iter`, and `std::iter::Chain` all get added to the dictionary because we have not seen them before. After that we encounter `std` again. We've already seen it, so we don't add anything to the dictionary. The same goes for when we encounter `std::iter` the second time. Next we encounter `std::iter::Zip`, which we have not seen before, so it's added to the dictionary. Next we encounter `std` again (already seen, no insertion), then `std::vec` and `std::vec::IntoIter` which both generate a new entry. Next we see `std::vec::IntoIter<u32>`, the first full _type_. It generates an entry too. The second type parameter is the same as the first. No part of it introduces a new entry. After the next `>` we have completely processed `std::iter::Zip<std::vec::IntoIter<u32>, std::vec::IntoIter<u32>>`, which adds another type entry. Finally, the full `std::iter::Chain<std::iter::Zip<std::vec::IntoIter<u32>, std::vec::IntoIter<u32>>>` adds another entry.

Using the dictionary above, we can compress to:

```
std::iter::Chain<$1::Zip<$0::vec::IntoIter<u32>, $6>>
```

A couple of things to note:

 - The first occurrence of a dictionary entry is never substituted. We don't store the dictionary anywhere and need to be able to reconstruct it from the compressed version.
 - Longer substitutions are preferred to shorter ones. `std::iter::Chain<$1::Zip<$0::vec::IntoIter<u32>, $4::IntoIter<u32>>>` would also decompress to the original version but the compiler is supposed to always pick the longest substitution available.

The mangled version of a substitution marker is `S <key - 1> _` (and `S_` for key `0`) like in the Itanium mangling. So the above definition would be mangled to:

```
_RN12std_a1b2c3d44iter5ChainINS0_3ZipINS_3vec8IntoIterIjEES5_EEE
```

The uncompressed version would be:
```
_RN12std_a1b2c3d44iter5ChainIN12std_a1b2c3d44iter3ZipIN12std_a1b2c3d43vec8IntoIterIjEEN12std_a1b2c3d43vec8IntoIterIjEEEEE
```

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

The reference-level explanation consists of three parts:

1. A specification of the syntax mangled names conform to.
2. A specification of the compression scheme.
3. A mapping of Rust entities to the mangling syntax.

For implementing a demangler, only the first two sections are of interest, that is, a demangler only needs to understand syntax and compression of names, but it does not have to care about how the compiler generates mangled names.


## Syntax Of Mangled Names

The syntax of mangled names is given in extended Backus-Naur form:

 - Non-terminals are within angle brackets (as in `<name-prefix>`)
 - Terminals are within quotes (as in `"_R"`),
 - Optional parts are in brackets (as in `[<decimal>]`),
 - Repetition (zero or more times) is signified by curly braces (as in `{ <name-prefix> }`)
 - Comments are marked with `//`.

Mangled names conform to the following grammar:

```
// The <decimal-number> specifies the encoding version.
<symbol-name> = "_R" [<decimal-number>] <absolute-path> [<instantiating-crate>]

<absolute-path> = "N" <path-prefix> [<generic-arguments>] "E"
                | <substitution>

<path-prefix> = <identifier>
              | "M" <type>
              | "X" <type> <absolute-path> [<disambiguator>]
              | <path-prefix> <identifier>
              | <substitution>

// The <decimal-number> is the length of the identifier in bytes.
// <bytes> is the identifier itself and must not start with a decimal digit.
// If the "u" is present then <bytes> is Punycode-encoded.
// "V" and "C" are the tags for value and closure namespaces respectively.
<identifier> = <decimal-number> <bytes> ["u"] ["V"|"C"] [<disambiguator>]

<type> = <basic-type>
       | <absolute-path>                  // named type
       | "A" [<decimal-number>] <type>    // [T; N]
       | "T" {<type>} "E"                 // (T1, T2, T3, ...)
       | "R" <type>                       // &T
       | "Q" <type>                       // &mut T
       | "P" <type>                       // *const T
       | "O" <type>                       // *mut T
       | "G" <identifier> "E"             // generic parameter name
       | <function-type>
       | <substitution>

<basic-type> = "a"      // i8
             | "b"      // bool
             | "c"      // char
             | "d"      // f64
             | "e"      // str
             | "f"      // f32
             | "h"      // u8
             | "i"      // isize
             | "j"      // usize
             | "l"      // i32
             | "m"      // u32
             | "n"      // i128
             | "o"      // u128
             | "s"      // i16
             | "t"      // u16
             | "u"      // ()
             | "v"      // ...
             | "x"      // i64
             | "y"      // u64
             | "z"      // !

// If the "U" is present then the function is `unsafe`.
// If the "J" is present then it is followed by the return type of the function.
<function-type> := "F" ["U"] [<abi>] {<type>} ["J" <type>] "E"

<abi> = "K" (
           "d" |   // Cdecl
           "s" |   // Stdcall
           "f" |   // Fastcall
           "v" |   // Vectorcall
           "t" |   // Thiscall
           "a" |   // Aapcs
           "w" |   // Win64
           "x" |   // SysV64
           "k" |   // PtxKernel
           "m" |   // Msp430Interrupt
           "i" |   // X86Interrupt
           "g" |   // AmdGpuKernel
           "c" |   // C
           "x" |   // System
           "r" |   // RustCall
           "j" |   // RustInstrinsic
           "p" |   // PlatformInstrinsic
           "u"     // Unadjusted
        )

// <base-62-number> uses 0-9-a-z-A-Z as digits, i.e. 'a' is decimal 10 and
// 'Z' is decimal 61.
<disambiguator> = "s" [<base-62-number>] "_"

<generic-arguments> = "I" {<type>} "E"

<substitution> = "S" [<base-62-number>] "_"

// We use <path-prefix> here, so that we don't have to add a special rule for
// compression. In practice, only <identifier> is expected.
<instantiating-crate> := <path-prefix>
```

### Punycode Identifiers

Punycode generates strings of the form `([[:ascii:]]+-)?[[:alnum:]]+`. This is problematic for two reasons:

- Generated strings can contain a `-` character; which is not in the supported character set.
- Generated strings can start with a digit; which makes them clash with the byte-count prefix of the `<identifier>` production.

For these reasons, vanilla Punycode string are further encoded during mangling:

- The `-` character is simply replaced by a `_` character.
- The part of the Punycode string that encodes the non-ASCII characters is a base-36 number, using `[a-z0-9]` as its "digits". We want to get rid of the decimal digits in there, so we simply remap `0-9` to `A-J`.

Here are some examples:

| Original        | Punycode        | Punycode + Encoding |
|-----------------|-----------------|---------------------|
| f√∏√∏             | f-5gaa          | f_Fgaa              |
| Œ±_œâ             | _-ylb7e         | __ylbHe             |
| ÈìÅÈîà             | n84amf          | nIEamf              |
| ü§¶              | fq9h            | fqJh                |
| œÅœÖœÉœÑ            | 2xaedc          | Cxaedc              |

With this post-processing in place the Punycode strings can be treated like regular identifiers and need no further special handling.


## Compression

From a high-level perspective symbol name compression works by substituting parts of the mangled name that have already been seen for a back-reference. Which parts are eligible for substitution is defined via the AST of the name (as described in the previous section). Before going into the actual algorithm, let's define some terms:

- Two AST nodes are *equivalent* if they contain the same information. In general this means that two nodes are equivalent if the sub-trees they are the root of are equal. However, there is another condition that can make two nodes equivalent. If a node `N` has a single child node `C` and `N` does not itself add any new information, then `N` and `C` are equivalent too. The exhaustive list of these special cases is:

  - `<absolute-path>` nodes without a `<generic-parameters>` child. These are equivalent to their `<path-prefix>` child node.

  - `<path-prefix>` nodes with a single `<type>` child. These are equivalent to their child node.

  - `<type>` nodes with a single `<absolute-path>` child. These too are equivalent to their child node.

  Equivalence is transitive, so given, for example, an AST of the form

  ```
      <type>
        |
        v
  <absolute-path>
        |
        v
   <path-prefix>
  ```

  then the `<type>` node is equivalent to the `<path-prefix>` node.

 - A *substitutable* AST node is any node with a `<substitution>` on the right-hand side of the production. Thus the exhaustive list of substitutable node types is: `<absolute-path>`, `<path-prefix>`, and `<type>`. There is one exception to this rule: nodes that are *equivalent* to a `<basic-type>` node, are not *substitutable*.

 - The "substitution dictionary" is a mapping from *substitutable* AST nodes to integer indices.

Given these definitions, compression is defined as follows.

 - Initialize the substitution dictionary to be empty.
 - Traverse and modify the AST as follows:
   - When encountering a substitutable node `N` there are two cases
     1. If the substitution dictionary already contains an *equivalent* node, replace the children of `N` with a `<substitution>` that encodes the substitution index taken from the dictionary.
     2. Else, continue traversing through the child nodes of `N`. After the child nodes have been traversed and if the dictionary does not yet contain an *equivalent* node, then allocate the next unused substitution index and add it to the substitution dictionary with `N` as its key.

The following gives an example of substitution index assignment and node replacements for `foo::Bar::quux<foo::Bar>` (with `quux` being an inherent method of `foo::Bar`). `#n` designates that the substitution index `n` was assigned to the given node and `:= #n` designates that it is replaced with a `<substitution>`:


```
                           <symbol-name>
                                 |
                          <absolute-path> #3
                         /               \
              <path-prefix> #2           <generic-arguments>
               /         \                             |
          <path-prefix>  <identifier "quux">         <type> := #1
             /                                         |
          <type>                                 <absolute-path>
            |                                          |
      <absolute-path>                             <path-prefix>
            |                                      /         \
      <path-prefix> #1                     <path-prefix>   <identifier "Bar">
           /       \                             /
<path-prefix> #0   <identifier "Bar">     <identifier "foo">
      |
<identifier "foo">
```

Some interesting things to note in this example:

 - There are substitutable nodes that are not replaced, nor added to the dictionary. This falls out of the equivalence rule. The node marked with `#1` is equivalent to its three immediate ancestors, so no dictionary entries are generated for those.

 - The `<type>` node marked with `:= #1` is replaced by `#1`, which is not a `<type>` but an (equivalent) `<path-prefix>`. This is OK and prescribed by the algorithm. The definition of equivalence ensures that there is only one valid way to construct a `<type>` node from a `<path-prefix>` node.


## Decompression

Decompression works analogously to compression, only this time, the substitution dictionary maps substitution indices to nodes instead of the other way round:

 - Initialize the substitution dictionary to be empty.
 - Traverse and modify the AST as follows:
   - When encountering a substitutable node `N` there are two cases
     1. If the node has a single `<substitution>` child, extract the substitution index from it and replace the node with the corresponding entry from the substitution dictionary.
     2. Else, continue traversing the child nodes of the current node. After the child nodes have been traversed, and if the dictionary does not yet contain an *equivalent* node, then allocate the next unused substitution index and add it to the substitution dictionary with `N` as its value.

This is what the example from above looks like for decompression:

```
                           <symbol-name>
                                 |
                          <absolute-path> #3
                         /               \
              <path-prefix> #2           <generic-arguments>
               /         \                             |
          <path-prefix>  <identifier "quux">         <type> := #1
             /                                         |
          <type>                                 <substitution #1>
            |
      <absolute-path>
            |
      <path-prefix> #1
           /       \
<path-prefix> #0   <identifier "Bar">
      |
<identifier "foo">
```

### A Note On Implementing Efficient Demanglers

The mangling syntax is constructed in a way that allows for implementing efficient demanglers:

 - Mangled names contain information in the same order as unmangled names are expected to contain it. Therefore, a demangler can directly generate its output while parsing the mangled form. There is no need to explicitly instantiate the AST in memory.

 - The same is true for decompression. The demangler can keep a simple array that maps substitution indices to ranges in the already generated output. When it encounters a `<substitution>` in need of expansion, it can just look up corresponding range and do a simple `memcpy`.

Parsing, decompression, and demangling can thus be done in a single pass over the mangled name without the need to do dynamic allocation except for the dictionary array.


## Mapping Rust Language Entities to Symbol Names

This RFC suggests the following mapping of Rust entities to mangled names:

- Free standing named functions and types shall be represented by an `<absolute-path>` production.

- Absolute paths should be rooted at the inner-most entity that can act as a path root. Roots can be crate-ids, types (for entities with an inherent impl in their path), and trait impls (for entities with trait impls in their path).

- The disambiguation index for an identifier in the type, value, and closure namespaces is determined by counting the number of occurrences of that identifier within its parent context (i.e. the fully macro-expanded AST). The disambiguation index `0` is represented by omitting the `<disambiguator>` production (which should be the common case).

- The compiler is free to choose disambiguation indices for specializing trait impls. Disambiguation indices do not need to be densely packed. In particular the compiler can use arbitrary hashes to disambiguate specializing trait impls.


# Drawbacks
[drawbacks]: #drawbacks

Why should we *not* do this?

- The scheme is complex, especially due to compression---albeit less complex than prior art and probably not more complex than the current scheme, if we were to describe that formally.
- The current/legacy scheme based on symbol-hashes is flexible in that hashes can be changed at will. That is, the unstable part of the current mangling scheme is nicely contained and does not keep breaking external tools. The danger of breakage is greater with the scheme proposed here because it exposes more information.


# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

The alternatives considered are:

 1. Keeping the current scheme. It does meet the minimum requirements after all. However, the general consensus seems to be that leads to situations where people are unpleasantly surprised when they come across (demangled) symbol names in backtraces or profilers.

 2. Keeping the current scheme but cleaning it up by making the non-hash part more consistent and more expressive. Keep the hash part as a safeguard against symbol conflicts and the rest as something just for demangling. The downside of this is that the hash would still not be predictable, and symbols would get rather long if they should contain more human-readable information about generic arguments.

 2. Define a standardized pretty-printing format for things that end up as symbols, and then encode that via Punycode in order to meet the character set restrictions. This would be rather simple. Symbol names would remain somewhat human-readable (but not very, because all separators would be stripped out). But without some kind of additional compression, symbol names would become rather long.

 3. Use the scheme from the previous bullet point but apply the compression scheme described above. We could do this but it wouldn't really be less complex than the Itanium inspired scheme proposed above.

 4. Define a standardized pretty-printing format for things that end up as symbols, compress with zstd (specially trained for Rust symbols) and encode the result as base63. This is rather simple but loses all human-readability. It's unclear how well this would compress. It would pull the zstd specification into the mangling scheme specification, as well as the pre-trained dictionary.

The Itanium mangling (and by extension the scheme proposed here) could be considered somewhat arcane. But it is well-known from C++ and provides a good trade-off between readability, complexity, and length of generated symbols.

# Prior art
[prior-art]: #prior-art

The mangling scheme described here is an adaptation of the [Itanium C++ ABI][itanium-mangling] scheme,
which is the scheme used by the GCC toolchain (and clang when it's not compiling for MSVC).

One notable improvement the proposed scheme makes upon Itanium mangling is explicit handling of
unicode identifiers. The idea of using [Punycode][punycode] for this is taken from the
[Swift][swift-gh] programming language's [mangling scheme][swift-mangling] (which is also based on
Itanium mangling).


[punycode]: https://tools.ietf.org/html/rfc3492
[itanium-mangling]: http://refspecs.linuxbase.org/cxxabi-1.86.html#mangling
[swift-gh]: https://github.com/apple/swift
[swift-mangling]: https://github.com/apple/swift/blob/master/docs/ABI/Mangling.rst#identifiers


# Unresolved questions
[unresolved-questions]: #unresolved-questions

### Punycode vs UTF-8
During the pre-RFC phase, it has been suggested that Unicode identifiers should be encoded as UTF-8 instead of Punycode on platforms that allow it. GCC, Clang, and MSVC seem to do this. The author of the RFC has a hard time making up their mind about this issue. Here are some interesting points that might influence the final decision:

- Using UTF-8 instead of Punycode would make mangled strings containing non-ASCII identifiers a bit more human-readable. For demangled strings, there would be no difference.

- Punycode support is non-optional since some platforms only allow a very limited character set for symbol names. Thus, we would be using UTF-8 on some platforms and Punycode on others, making it harder to predict what a symbol name for a given item looks like.

- Punycode encoding and decoding is more runtime effort for the mangler and demangler.

- Once a demangler supports Punycode, it is not much effort to support both encodings. The `u` identifier suffix tells the demangler whether it's Punycode. Otherwise it can just assume UTF-8 which already subsumes ASCII.

### Re-use <disambiguator> for crate disambiguator

The RFC currently proposes to represent crate-ids as an `<identifier>` of the form `<name>_<disambiguator>`. However, the `<identifier>` production already supports disambiguation via its `<disambiguator>` component. The crate disambiguator could be encoded into an disambiguation index.

# Appendix A - Suggested Demangling

This RFC suggests that names are demangled to a form that matches Rust syntax as it is used in source code, compiler error messages and `rustdoc`:

 - Path components should be separated by `::`.

 - If the path root is a `<crate-id>` it should be printed as the crate name. If the context requires it for correctness, the crate disambiguator should be printed too, as in, for example, `std[a0b1c2d3]::collections::HashMap`. In this case `a0b1c2d3` would be the disambiguator. Usually, the disambiguator can be omitted for better readability.

 - If the path root is a trait impl, it should be printed as `<SelfType as Trait>`, like the compiler does in error messages.

 - The list of generic arguments should be demangled as `<T1, T2, T3>`.

 - Identifiers and trait impl path roots can have a numeric disambiguator (the `<disambiguator>` production). The syntactic version of the numeric disambiguator maps to a numeric index. If the disambiguator is not present, this index is 0. If it is of the form `s_` then the index is 1. If it is of the form `s<base-62-digit>_` then the index is `<base-62-digit> + 2`. The suggested demangling of a disambiguator is `[<index>]`. However, for better readability, these disambiguators should usually be omitted in the demangling altogether. Disambiguators with index zero can always be omitted.

 The exception here are closures. Since these do not have a name, the disambiguator is the only thing identifying them. The suggested demangling for closures is thus `{closure}[<index>]`.

 - In a lossless demangling, identifiers from the value namespace should be marked with a `'` suffix in order to avoid conflicts with identifiers from the type namespace. In a user-facing demangling, where such conflicts are acceptable, the suffix can be omitted.

# Appendix B - Interesting Examples

We assume that all examples are defined in a crate named `mycrate[xxx]`.


### Free-standing Item

```rust
mod foo {
  mod bar {
    fn baz() {}
  }
}
```
- unmangled: `mycrate::foo::bar::baz`
- mangled: `_RN11mycrate_xxx3foo3bar3bazVE`


### Item Defined In Inherent Method

```rust
struct Foo<T>(T);

impl<T> Foo<T> {
  pub fn bar<U>(_: U) {
    static QUUX: u32 = 0;
    // ...
  }
}
```
- unmangled: `mycrate::Foo::bar::QUUX`
- mangled: `_RNMN11mycrate_xxx3FooE3barV4QUUXVE`


### Item Defined In Trait Method

```rust
struct Foo<T>(T);

impl<T> Clone for Foo<T> {
  fn clone<U>(_: U) {
    static QUUX: u32 = 0;
    // ...
  }
}
```
- unmangled: `<mycrate::Foo as std::clone::Clone>::clone::QUUX`
- mangled: `_RNXN11mycrate_xxx3FooEN7std_yyy5clone5CloneE5cloneV4QUUXVE`


### Item Defined In Specializing Trait Impl
```rust
struct Foo<T>(T);

impl<T> Clone for Foo<T> {
  default fn clone<U>(_: U) {
    static QUUX: u32 = 0;
    // ...
  }
}
```
- unmangled: `<mycrate::Foo as std::clone::Clone>[1234]::clone::QUUX`
- mangled: `_RNXN11mycrate_xxx3FooEN7std_yyy5clone5CloneEsjU_5cloneV4QUUXVE`


### Item Defined In Initializer Of A Static
```rust
pub static QUUX: u32 = {
  static FOO: u32 = 1;
  FOO + FOO
};
```
- unmangled: `mycrate::QUUX::FOO`
- mangled: `_RN11mycrate_xxx4QUUXV3FOOVE`


### Compressed Prefix Constructed From Prefix That Contains A Substitution Itself
- unmangled: `std[xxx]::foo<std[xxx]::bar,std[xxx]::bar::baz>`
- mangled: `_RN7std_xxx3fooFINS_3barFENS1_3bazFEEE`


### Progressive type compression
- unmangled: `std[xxx]::foo<(std[xxx]::Bar,std[xxx]::Bar),(std[xxx]::Bar,std[xxx]::Bar)>`
- mangled: `_RN7std_xxx3fooITNS_3BarES1_ES2_EE`
